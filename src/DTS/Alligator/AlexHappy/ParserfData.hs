{-# OPTIONS  #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}


-- parser (data) produced by Happy (GLR) Version 1.19.11

module DTS.Alligator.AlexHappy.ParserfData where





import DTS.Alligator.AlexHappy.Lexerf
import DTS.Alligator.AlexHappy.Syntaxf
import qualified Data.List as L           -- base

import Control.Monad.Except
import qualified Data.Array as Happy_Data_Array
import qualified Data.Bits as Bits
import Control.Applicative(Applicative(..))
import Control.Monad (ap)



{-# LINE 1 "templates/GLR_Base.hs" #-}
{-# LINE 1 "templates/GLR_Base.hs" #-}
{-# LINE 1 "<built-in>" #-}
{-# LINE 15 "<built-in>" #-}
{-# LINE 1 "/usr/local/Cellar/ghc/8.6.5/lib/ghc-8.6.5/include/ghcversion.h" #-}
















{-# LINE 16 "<built-in>" #-}
{-# LINE 1 "/var/folders/2s/x156s9rn0dbb07ymqyg052g40000gn/T/ghc37689_0/ghc_2.h" #-}

















































































































































































































































{-# LINE 17 "<built-in>" #-}
{-# LINE 1 "templates/GLR_Base.hs" #-}
{- GLR_Base.lhs
   Id: GLR_Base.lhs,v 1.4 2004/12/04 15:01:37 paulcc Exp 
-}

-- Basic defs required for compiling the data portion of the parser

-- We're creating Int-indexed graphs

type ForestId  = (Int,Int,GSymbol)


-- Actions for the GLR machine

data GLRAction = Shift Int [Reduction]
               | Reduce [Reduction]
               | Accept
               | Error

---
-- A Reduction (s,n,f) removes the top n node-ids, creates a new branch from these
-- and labels the branch with the given symbol s. Additionally, the branch may
-- hold some semantic value.

type Reduction = (GSymbol,Int, [ForestId] -> Branch)


---
-- A Branch holds the semantic result plus node ids of children

data Branch
 = Branch {b_sem :: GSem, b_nodes :: [ForestId]}
   deriving Show

instance Eq Branch where
        b1 == b2 = b_nodes b1 == b_nodes b2



-------------------------------------------------------------------------------
-- Utilities for decoding

---
-- Tree decode unpacks the forest into a list of results
--  - this is ok for small examples, but inefficient for very large examples
--  - the data file contains further instances
--  - see documentation for further information
--  - "Decode_Result" is a synonym used to insert the monad type constr (or not)

class TreeDecode a where
        decode_b :: (ForestId -> [Branch]) -> Branch -> [Decode_Result a]

decode :: TreeDecode a => (ForestId -> [Branch]) -> ForestId -> [Decode_Result a]
decode f i@(_,_,HappyTok t)
  = decode_b f (Branch (SemTok t) [])
decode f i
  = [ d | b <- f i, d <- decode_b f b ]

---- generated by Happy, since it means expansion of synonym (not ok in H-98)
--instance TreeDecode UserDefTok where
--      decode_b f (Branch (SemTok t) []) = [happy_return t]

---
-- this is used to multiply the ambiguous possibilities from children

--cross_fn :: [a -> b] -> [a] -> [b]
--actual type will depend on monad in use.
--happy_ap defined by parser generator
cross_fn fs as = [ f `happy_ap` a | f <- fs, a <- as]

---
-- Label decoding unpacks from the Semantic wrapper type
--  - this allows arbitrary values (within the limits of the compiler settings)
--    to be recovered from nodes in the tree.
--  - again, more instances are written in the data file
--  - see documentation for further information

class LabelDecode a where
        unpack :: GSem -> a

---- generated by Happy, since it means expansion of synonym (not ok in H-98)
--instance LabelDecode UserDefTok where
--      unpack (SemTok t) = t





{-# LINE 376 "DTS/Alligator/AlexHappy/ParserfData.hs"#-}

parseError :: [Token] -> Except String a
parseError (l:ls) = throwError (show l)
parseError [] = throwError "Unexpected end of Input"

parseExpr :: String -> Either String Expr
parseExpr input =
  let tokenStream = scanTokens input in
  runExcept (expr tokenStream)

{-# LINE 387 "DTS/Alligator/AlexHappy/ParserfData.hs"#-}

data GSymbol = HappyEOF | HappyTok {-!Int-} (Token) | G_formula 
   deriving (Show,Eq,Ord)

data GSem
 = NoSem
 | SemTok (Token) | Sem_0 (()) 
 | Sem_1 (()) 
 | Sem_2 (()) 
 | Sem_3 (()) 
 | Sem_4 (()) 
   deriving (Show)


semfn_0_0 ns@((_,_,HappyTok ((TokenWord happy_var_1))):happy_rest) =  Branch (Sem_0 (Tletter happy_var_1)) ns
semfn_1_0 ns@(happy_rest) =  Branch (Sem_1 (Ttrue)) ns
semfn_1_1 ns@(happy_rest) =  Branch (Sem_1 (Tfalse)) ns
semfn_2_0 ns@(happy_var_1:happy_var_2:happy_rest) =  Branch (Sem_2 (Tneg happy_var_2)) ns
semfn_2_1 ns@(happy_var_1:happy_var_2:happy_rest) =  Branch (Sem_2 (happy_var_2)) ns
semfn_3_0 ns@(happy_var_1:happy_var_2:happy_var_3:happy_rest) =  Branch (Sem_3 (Tbinary Tand happy_var_1 happy_var_3)) ns
semfn_3_1 ns@(happy_var_1:happy_var_2:happy_var_3:happy_rest) =  Branch (Sem_3 (Tbinary Tor happy_var_1 happy_var_3)) ns
semfn_3_2 ns@(happy_var_1:happy_var_2:happy_var_3:happy_rest) =  Branch (Sem_3 (Tbinary Timp happy_var_1 happy_var_3)) ns
semfn_3_3 ns@(happy_var_1:happy_var_2:happy_var_3:happy_rest) =  Branch (Sem_3 (Tbinary Tequiv happy_var_1 happy_var_3)) ns
semfn_4_0 ns@(happy_var_1:happy_var_2:(_,_,HappyTok ((TokenWord happy_var_3))):happy_var_4:happy_var_5:happy_var_6:happy_rest) =  Branch (Sem_4 (Tall [Tvar happy_var_3] happy_var_6)) ns
semfn_4_1 ns@(happy_var_1:happy_var_2:(_,_,HappyTok ((TokenWord happy_var_3))):happy_var_4:happy_var_5:happy_var_6:happy_rest) =  Branch (Sem_4 (Texist [Tvar happy_var_3] happy_var_6)) ns


happy_join x = ((>>=)) x id
happy_ap f a = ((>>=)) f (\f -> ((>>=)) a (\a -> return(f a)))
type Decode_Result a = (Except String) a
happy_return = return :: a -> Decode_Result a
instance LabelDecode (()) where 
  unpack (Sem_0 s) = s
  unpack (Sem_1 s) = s
  unpack (Sem_2 s) = s
  unpack (Sem_3 s) = s
  unpack (Sem_4 s) = s


type UserDefTok = Token
instance TreeDecode (Token) where
  decode_b f (Branch (SemTok t) []) = [happy_return t]
instance LabelDecode (Token) where
  unpack (SemTok t) = t


action 0 ( HappyTok (TokenNeg) ) = Shift 4 []
action 0 ( HappyTok (TokenWord _) ) = Shift 2 []
action 0 ( HappyTok (TokenTop) ) = Shift 5 []
action 0 ( HappyTok (TokenBot) ) = Shift 6 []
action 0 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 0 ( HappyTok (TokenAll) ) = Shift 8 []
action 0 ( HappyTok (TokenExists) ) = Shift 9 []
action 1 ( HappyTok (TokenWord _) ) = Shift 2 []
action 2 ( HappyTok (TokenAnd) ) = Reduce [red_1]
action 2 ( HappyTok (TokenOr) ) = Reduce [red_1]
action 2 ( HappyTok (TokenImp) ) = Reduce [red_1]
action 2 ( HappyTok (TokenEquiv) ) = Reduce [red_1]
action 2 ( HappyTok (TokenRBracket) ) = Reduce [red_1]
action 2 ( HappyEOF ) = Reduce [red_1]
action 3 ( HappyTok (TokenAnd) ) = Shift 14 []
action 3 ( HappyTok (TokenOr) ) = Shift 15 []
action 3 ( HappyTok (TokenImp) ) = Shift 16 []
action 3 ( HappyTok (TokenEquiv) ) = Shift 17 []
action 3 ( HappyEOF ) = Accept
action 4 ( HappyTok (TokenNeg) ) = Shift 4 []
action 4 ( HappyTok (TokenWord _) ) = Shift 2 []
action 4 ( HappyTok (TokenTop) ) = Shift 5 []
action 4 ( HappyTok (TokenBot) ) = Shift 6 []
action 4 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 4 ( HappyTok (TokenAll) ) = Shift 8 []
action 4 ( HappyTok (TokenExists) ) = Shift 9 []
action 5 ( HappyTok (TokenAnd) ) = Reduce [red_2]
action 5 ( HappyTok (TokenOr) ) = Reduce [red_2]
action 5 ( HappyTok (TokenImp) ) = Reduce [red_2]
action 5 ( HappyTok (TokenEquiv) ) = Reduce [red_2]
action 5 ( HappyTok (TokenRBracket) ) = Reduce [red_2]
action 5 ( HappyEOF ) = Reduce [red_2]
action 6 ( HappyTok (TokenAnd) ) = Reduce [red_3]
action 6 ( HappyTok (TokenOr) ) = Reduce [red_3]
action 6 ( HappyTok (TokenImp) ) = Reduce [red_3]
action 6 ( HappyTok (TokenEquiv) ) = Reduce [red_3]
action 6 ( HappyTok (TokenRBracket) ) = Reduce [red_3]
action 6 ( HappyEOF ) = Reduce [red_3]
action 7 ( HappyTok (TokenNeg) ) = Shift 4 []
action 7 ( HappyTok (TokenWord _) ) = Shift 2 []
action 7 ( HappyTok (TokenTop) ) = Shift 5 []
action 7 ( HappyTok (TokenBot) ) = Shift 6 []
action 7 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 7 ( HappyTok (TokenAll) ) = Shift 8 []
action 7 ( HappyTok (TokenExists) ) = Shift 9 []
action 8 ( HappyTok (TokenRLBracket) ) = Shift 11 []
action 9 ( HappyTok (TokenRRBracket) ) = Shift 10 []
action 10 ( HappyTok (TokenWord _) ) = Shift 24 []
action 11 ( HappyTok (TokenWord _) ) = Shift 23 []
action 12 ( HappyTok (TokenAnd) ) = Shift 14 []
action 12 ( HappyTok (TokenOr) ) = Shift 15 []
action 12 ( HappyTok (TokenImp) ) = Shift 16 []
action 12 ( HappyTok (TokenEquiv) ) = Shift 17 []
action 12 ( HappyTok (TokenRBracket) ) = Shift 22 []
action 13 ( HappyTok (TokenAnd) ) = Shift 14 [red_4]
action 13 ( HappyTok (TokenOr) ) = Shift 15 [red_4]
action 13 ( HappyTok (TokenImp) ) = Shift 16 [red_4]
action 13 ( HappyTok (TokenEquiv) ) = Shift 17 [red_4]
action 13 ( HappyTok (TokenRBracket) ) = Reduce [red_4]
action 13 ( HappyEOF ) = Reduce [red_4]
action 14 ( HappyTok (TokenNeg) ) = Shift 4 []
action 14 ( HappyTok (TokenWord _) ) = Shift 2 []
action 14 ( HappyTok (TokenTop) ) = Shift 5 []
action 14 ( HappyTok (TokenBot) ) = Shift 6 []
action 14 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 14 ( HappyTok (TokenAll) ) = Shift 8 []
action 14 ( HappyTok (TokenExists) ) = Shift 9 []
action 15 ( HappyTok (TokenNeg) ) = Shift 4 []
action 15 ( HappyTok (TokenWord _) ) = Shift 2 []
action 15 ( HappyTok (TokenTop) ) = Shift 5 []
action 15 ( HappyTok (TokenBot) ) = Shift 6 []
action 15 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 15 ( HappyTok (TokenAll) ) = Shift 8 []
action 15 ( HappyTok (TokenExists) ) = Shift 9 []
action 16 ( HappyTok (TokenNeg) ) = Shift 4 []
action 16 ( HappyTok (TokenWord _) ) = Shift 2 []
action 16 ( HappyTok (TokenTop) ) = Shift 5 []
action 16 ( HappyTok (TokenBot) ) = Shift 6 []
action 16 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 16 ( HappyTok (TokenAll) ) = Shift 8 []
action 16 ( HappyTok (TokenExists) ) = Shift 9 []
action 17 ( HappyTok (TokenNeg) ) = Shift 4 []
action 17 ( HappyTok (TokenWord _) ) = Shift 2 []
action 17 ( HappyTok (TokenTop) ) = Shift 5 []
action 17 ( HappyTok (TokenBot) ) = Shift 6 []
action 17 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 17 ( HappyTok (TokenAll) ) = Shift 8 []
action 17 ( HappyTok (TokenExists) ) = Shift 9 []
action 18 ( HappyTok (TokenAnd) ) = Shift 14 [red_9]
action 18 ( HappyTok (TokenOr) ) = Shift 15 [red_9]
action 18 ( HappyTok (TokenImp) ) = Shift 16 [red_9]
action 18 ( HappyTok (TokenEquiv) ) = Shift 17 [red_9]
action 18 ( HappyTok (TokenRBracket) ) = Reduce [red_9]
action 18 ( HappyEOF ) = Reduce [red_9]
action 19 ( HappyTok (TokenAnd) ) = Shift 14 [red_8]
action 19 ( HappyTok (TokenOr) ) = Shift 15 [red_8]
action 19 ( HappyTok (TokenImp) ) = Shift 16 [red_8]
action 19 ( HappyTok (TokenEquiv) ) = Shift 17 [red_8]
action 19 ( HappyTok (TokenRBracket) ) = Reduce [red_8]
action 19 ( HappyEOF ) = Reduce [red_8]
action 20 ( HappyTok (TokenAnd) ) = Shift 14 [red_7]
action 20 ( HappyTok (TokenOr) ) = Shift 15 [red_7]
action 20 ( HappyTok (TokenImp) ) = Shift 16 [red_7]
action 20 ( HappyTok (TokenEquiv) ) = Shift 17 [red_7]
action 20 ( HappyTok (TokenRBracket) ) = Reduce [red_7]
action 20 ( HappyEOF ) = Reduce [red_7]
action 21 ( HappyTok (TokenAnd) ) = Shift 14 [red_6]
action 21 ( HappyTok (TokenOr) ) = Shift 15 [red_6]
action 21 ( HappyTok (TokenImp) ) = Shift 16 [red_6]
action 21 ( HappyTok (TokenEquiv) ) = Shift 17 [red_6]
action 21 ( HappyTok (TokenRBracket) ) = Reduce [red_6]
action 21 ( HappyEOF ) = Reduce [red_6]
action 22 ( HappyTok (TokenAnd) ) = Reduce [red_5]
action 22 ( HappyTok (TokenOr) ) = Reduce [red_5]
action 22 ( HappyTok (TokenImp) ) = Reduce [red_5]
action 22 ( HappyTok (TokenEquiv) ) = Reduce [red_5]
action 22 ( HappyTok (TokenRBracket) ) = Reduce [red_5]
action 22 ( HappyEOF ) = Reduce [red_5]
action 23 ( HappyTok (TokenRRBracket) ) = Shift 26 []
action 24 ( HappyTok (TokenRLBracket) ) = Shift 25 []
action 25 ( HappyTok (TokenCoron) ) = Shift 28 []
action 26 ( HappyTok (TokenCoron) ) = Shift 27 []
action 27 ( HappyTok (TokenNeg) ) = Shift 4 []
action 27 ( HappyTok (TokenWord _) ) = Shift 2 []
action 27 ( HappyTok (TokenTop) ) = Shift 5 []
action 27 ( HappyTok (TokenBot) ) = Shift 6 []
action 27 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 27 ( HappyTok (TokenAll) ) = Shift 8 []
action 27 ( HappyTok (TokenExists) ) = Shift 9 []
action 28 ( HappyTok (TokenNeg) ) = Shift 4 []
action 28 ( HappyTok (TokenWord _) ) = Shift 2 []
action 28 ( HappyTok (TokenTop) ) = Shift 5 []
action 28 ( HappyTok (TokenBot) ) = Shift 6 []
action 28 ( HappyTok (TokenLBracket) ) = Shift 7 []
action 28 ( HappyTok (TokenAll) ) = Shift 8 []
action 28 ( HappyTok (TokenExists) ) = Shift 9 []
action 29 ( HappyTok (TokenAnd) ) = Shift 14 [red_11]
action 29 ( HappyTok (TokenOr) ) = Shift 15 [red_11]
action 29 ( HappyTok (TokenImp) ) = Shift 16 [red_11]
action 29 ( HappyTok (TokenEquiv) ) = Shift 17 [red_11]
action 29 ( HappyTok (TokenRBracket) ) = Reduce [red_11]
action 29 ( HappyEOF ) = Reduce [red_11]
action 30 ( HappyTok (TokenAnd) ) = Shift 14 [red_10]
action 30 ( HappyTok (TokenOr) ) = Shift 15 [red_10]
action 30 ( HappyTok (TokenImp) ) = Shift 16 [red_10]
action 30 ( HappyTok (TokenEquiv) ) = Shift 17 [red_10]
action 30 ( HappyTok (TokenRBracket) ) = Reduce [red_10]
action 30 ( HappyEOF ) = Reduce [red_10]
action _ _ = Error
red_1 = (G_formula,1 :: Int,semfn_0_0)
red_2 = (G_formula,1 :: Int,semfn_1_0)
red_3 = (G_formula,1 :: Int,semfn_1_1)
red_4 = (G_formula,2 :: Int,semfn_2_0)
red_5 = (G_formula,3 :: Int,semfn_2_1)
red_6 = (G_formula,3 :: Int,semfn_3_0)
red_7 = (G_formula,3 :: Int,semfn_3_1)
red_8 = (G_formula,3 :: Int,semfn_3_2)
red_9 = (G_formula,3 :: Int,semfn_3_3)
red_10 = (G_formula,6 :: Int,semfn_4_0)
red_11 = (G_formula,6 :: Int,semfn_4_1)
goto 0 G_formula = 3

goto 4 G_formula = 13

goto 7 G_formula = 12

goto 14 G_formula = 21

goto 15 G_formula = 20

goto 16 G_formula = 19

goto 17 G_formula = 18

goto 27 G_formula = 30

goto 28 G_formula = 29

goto _ _ = -1
